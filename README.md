# 알고리즘
## 12/10 화

### 3813 그래도 수명이 절반이 되어서는...

```
K의 순서가 섞이면 안된다...;;;

최댓값을 최소화하는 형태 => 최적화문제

Wear level 의 최댓값이 어떤 정수 c가 되도록 k개의 덩어리를 선택할 수 있는가 (T/F 문제로 바뀜)

이분탐색으로!

어느 수를 기준으로 작은쪽은 불가능, 큰쪽은 가능으로 바뀌게된다. 이 수가 답!

그래서 가운데를 보자. 가운데가 가능하다면, 기준으로 왼쪽의 가운데 확인. 불가능하다면 오른쪽으로 이분탐색 지속.

C를 늘려가면서 블록들을 확인.
가장 앞의 블록을 가능한 가장 작은 인덱스부터 채워나가면서 가능한지 여부 확인.

이 C를 이분탐색으로 검색해가면서 확인한다.
```

### 3820 롤러코스터

```
그냥 완전탐색은 N! * N;;;
거기다가 N이 작아도 숫자도 계산해야하기때문에 거의 불가;;

정답 배치를 선택하고, 그 계산도중 나머지계산을 해가면서 해야한다.

정답 배치는, 그 중 i번째와 i + 1번째를 바꾼 배치보다 속력이 작거나 같을 수 밖에 없다.

특정한 구간부터 그 후의 배치가 같다면, 그 구간까지의 결과값에 따라 총 결과가 정해진다. 

즉 (ai-1)/bi 값으로 내림차순 정리한 배치가 정답배치다.
 => 계산시 현재 속도 v는 지워져서 의미가읎다.
```

### 2930 힙

```

```

 

## 12/12 목

### Indexed tree

숫자의 갱신과 주어지는 구간 [a:b]에 대해서 원하는 연산을 log N의 시간복잡도로 해결해줄 수 있는 자료구조.

- 합이랑 최댓값, 최솟값, 곱셈 만 가능.

그냥 배열을 쓰면 교체, 연산 중 하나만 빠르고 다른건 느렸는데 얘는 평균적으로 log N



### Inverse Counting

```
Divide & Conquer 도 가능하나, 어렵다

Indexed tree로 풀자!

풀이 : 
```

